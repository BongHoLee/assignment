# Redisson RRateLimiter 면접관 평가 가이드

## 1. 평가 개요

### 1.1 Redisson RRateLimiter의 위치
Redisson RRateLimiter는 **분산 환경에서의 완벽한 동기화**를 목표로 하는 엔터프라이즈급 Rate Limiting 솔루션입니다. 단순한 Rate Limiting을 넘어서 분산 시스템의 복잡한 동기화 문제를 해결하는 도구입니다.

### 1.2 평가 관점
- **분산 시스템 이해**: 분산 환경에서의 동기화 복잡성 인식
- **엔터프라이즈 도구 선택**: 완성도 높은 도구 활용 능력
- **트레이드오프 판단**: 복잡성 vs 완성도의 균형점
- **실무 적용성**: 언제 이런 수준의 솔루션이 필요한지 판단

## 2. 핵심 평가 포인트

### 2.1 분산 동기화 이해 ⭐⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] PER_CLIENT와 OVERALL 모드의 차이를 명확히 이해하는가?
- [ ] 분산 환경에서 Rate Limiting의 어려움을 인식하는가?
- [ ] Redisson이 제공하는 분산 동기화 가치를 아는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "PER_CLIENT와 OVERALL 모드는 언제 각각 사용하나요?"

**기대 답변**:
```kotlin
// PER_CLIENT: 각 애플리케이션 인스턴스별 독립 제한
// 시나리오: 마이크로서비스간 호출 보호
rateLimiter.trySetRate(RateType.PER_CLIENT, 100, 1, RateIntervalUnit.SECONDS)
// 인스턴스 3개 → 총 300 TPS 가능

// OVERALL: 모든 인스턴스 통합 제한  
// 시나리오: 외부 API 호출 제한, 전체 시스템 부하 제어
rateLimiter.trySetRate(RateType.OVERALL, 100, 1, RateIntervalUnit.SECONDS)  
// 인스턴스 3개 → 총 100 TPS만 허용
```

**⭐ 심화 질문**: "분산 환경에서 OVERALL 모드의 일관성은 어떻게 보장되나요?"

**기대 답변**:
- **원자적 연산**: Lua Script를 통한 Redis 원자성
- **단일 포인트**: 모든 인스턴스가 동일한 Redis 키 참조
- **클러스터 일관성**: Redis 클러스터의 강일관성 보장

#### Trade-offs 이해도 확인
**PER_CLIENT**: 높은 처리량, 단순한 구현 vs 전체 제어 어려움
**OVERALL**: 정확한 전체 제어 vs 복잡한 분산 동기화, 성능 오버헤드

### 2.2 동작 모드별 이해 ⭐⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] IMMEDIATE, BLOCKING, FORCE_ACQUIRE 모드를 구별할 수 있는가?
- [ ] 각 모드의 적절한 사용 시나리오를 아는가?
- [ ] BLOCKING 모드에서의 데드락 위험을 인식하는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "각 모드는 언제 사용하며, 어떤 위험이 있나요?"

**기대 답변**:
```kotlin
// IMMEDIATE: 일반적인 API 보호
val acquired = rateLimiter.tryAcquire(1)
// 장점: 빠른 응답, 단점: 엄격한 거부

// BLOCKING: 중요한 작업, 약간의 대기 허용
val acquired = rateLimiter.tryAcquire(1, 3, TimeUnit.SECONDS)
// 장점: 부드러운 제어, 단점: 응답 지연

// FORCE_ACQUIRE: 배치 작업
rateLimiter.acquire(1) // 무제한 대기
// 위험: 데드락 가능성, 무한 대기
```

**⭐ 심화 질문**: "BLOCKING 모드에서 데드락이 발생할 수 있는 상황은?"

**기대 답변**:
- **순환 대기**: 서로 다른 리소스를 기다리는 상황
- **타임아웃 미설정**: 무한 대기로 인한 스레드 고갈
- **중첩 락**: 다른 동기화와 함께 사용시 위험

### 2.3 Redisson 선택 기준 ⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] 언제 Redisson을 선택해야 하는지 판단할 수 있는가?
- [ ] Redisson의 장단점을 균형있게 평가하는가?
- [ ] 대안 솔루션과 비교할 수 있는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "어떤 상황에서 Redisson RRateLimiter를 선택하시겠습니까?"

**기대 답변**:
**적합한 상황**:
- 대규모 분산 시스템
- 정확한 동기화가 중요한 비즈니스
- 복잡한 Rate Limiting 요구사항
- Redis 클러스터 환경

**부적합한 상황**:
- 단일 인스턴스 환경
- 단순한 내부 API 보호
- 가벼운 마이크로서비스
- Redis 인프라가 없는 환경

**⭐ 심화 질문**: "직접 구현 vs Redisson 활용의 기준은 무엇인가요?"

**기대 답변**:
- **요구사항 복잡도**: 단순 → 직접, 복잡 → Redisson
- **팀 전문성**: 전문팀 → 직접, 일반팀 → Redisson
- **시간적 여유**: 충분 → 직접, 촉박 → Redisson
- **유지보수성**: 장기 → 직접, 단기 → Redisson

### 2.4 실무 운영 고려사항 ⭐⭐⭐

#### WHAT을 확인하세요
- [ ] Redisson 설정 최적화를 이해하는가?
- [ ] 클러스터/Sentinel 환경 구성을 아는가?
- [ ] 모니터링과 문제 해결 방법을 제시할 수 있는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "프로덕션 환경에서 Redisson 설정시 주의사항은?"

**기대 답변**:
```kotlin
// 연결 풀 최적화
config.useSingleServer()
    .setConnectionMinimumIdleSize(10)  // 최소 유지 연결
    .setConnectionPoolSize(50)         // 최대 연결 수
    .setConnectTimeout(3000)           // 연결 타임아웃
    .setTimeout(2000)                  // 명령 타임아웃
    .setRetryAttempts(3)               // 재시도 횟수

// 모니터링 고려사항
- 연결 풀 사용률
- Redis 메모리 사용량  
- Rate Limiter 키 분포
- 장애 복구 횟수
```

## 3. 심화 평가 질문

### 3.1 대규모 환경 적용 ⭐⭐⭐⭐⭐

**질문**: "하루 10억 요청을 처리하는 시스템에서 Redisson RRateLimiter를 어떻게 운영하시겠습니까?"

**기대 답변**:
- **클러스터 구성**: Redis 클러스터로 부하 분산
- **샤딩 전략**: 사용자/서비스별 키 분산
- **로컬 캐싱**: 설정 정보 로컬 캐시
- **계층적 제한**: 초/분/시간 단위별 분리

### 3.2 장애 상황 대응 ⭐⭐⭐⭐

**질문**: "Redis 클러스터에서 일부 노드가 장애가 나면 Rate Limiter는 어떻게 동작하나요?"

**기대 답변**:
- **자동 페일오버**: Redisson의 자동 장애 감지 및 복구
- **일시적 불일치**: 페일오버 중 짧은 시간 동안 부정확한 카운팅
- **복구 전략**: 장애 복구 후 점진적 정상화
- **모니터링**: 장애 상황 감지 및 알림

### 3.3 성능 최적화 ⭐⭐⭐⭐

**질문**: "Redisson RRateLimiter의 성능을 개선하려면 어떤 방법이 있을까요?"

**기대 답변**:
- **로컬 캐싱**: 자주 사용하는 permits 로컬 보관
- **배치 처리**: 여러 permits를 한 번에 획득
- **비동기 처리**: Reactive API 활용
- **키 설계**: Hot Key 문제 방지

## 4. 점수 기준

### 4.1 기본 구현 (60점)
- [ ] Redisson 기본 사용법 이해
- [ ] 간단한 Rate Limiter 설정
- [ ] IMMEDIATE 모드 구현

### 4.2 고급 구현 (80점)
- [ ] PER_CLIENT vs OVERALL 적절한 선택
- [ ] BLOCKING 모드 활용
- [ ] 기본적인 설정 최적화
- [ ] 사용자 식별 전략

### 4.3 우수한 구현 (90점 이상)
- [ ] 분산 동기화 문제 깊은 이해
- [ ] 각 모드별 위험성 인식 및 대응
- [ ] 실무적 운영 고려사항 제시
- [ ] 대안 솔루션과의 명확한 비교

## 5. 일반적인 실수와 지적 포인트

### 5.1 모드 선택 실수
❌ **잘못된 접근**:
```kotlin
// 단순 API 보호에 OVERALL 모드 사용
rateLimiter.trySetRate(RateType.OVERALL, 1000, 1, RateIntervalUnit.SECONDS)
// 모든 인스턴스가 동일한 제한 공유 → 성능 저하
```

✅ **올바른 접근**: 용도에 맞는 모드 선택

### 5.2 데드락 위험 무시
❌ **문제**: FORCE_ACQUIRE 남용
✅ **해결**: 타임아웃 설정, BLOCKING 모드 선호

### 5.3 설정 최적화 부족
❌ **문제**: 기본 설정으로만 운영
✅ **해결**: 환경에 맞는 연결 풀, 타임아웃 설정

## 6. 면접 진행 팁

### 6.1 순서
1. 분산 환경에서의 Rate Limiting 어려움 확인 (5분)
2. PER_CLIENT vs OVERALL 차이 설명 (10분)
3. 각 모드별 사용 시나리오 토론 (10분)  
4. 실무 적용 고려사항 논의 (5분)

### 6.2 체크 포인트
- 분산 시스템의 복잡성을 이해하는가?
- 각 모드와 기능의 장단점을 균형있게 파악하는가?
- 실무 환경에서의 운영 위험을 고려하는가?
- 과도한 엔지니어링의 위험성을 인식하는가?

## 7. 마무리

Redisson RRateLimiter는 **분산 환경에서의 완벽한 동기화**라는 명확한 가치를 제공하는 전문적 도구입니다. 지원자가 이 도구의 파워와 복잡성을 모두 이해하고, 적절한 상황 판단을 할 수 있는지 평가해주세요.

**좋은 답변의 특징**:
- 분산 동기화 문제의 복잡성 인식
- 각 기능별 적절한 사용 시나리오 제시
- 실무 운영시 고려사항 구체적 언급
- 과도한 엔지니어링 위험성 인식