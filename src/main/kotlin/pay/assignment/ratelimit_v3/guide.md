# Sliding Window Rate Limiter 면접관 평가 가이드

## 1. 평가 개요

### 1.1 Sliding Window의 핵심 가치
Sliding Window는 **정확성을 최우선으로 하는 Rate Limiting 시나리오**에서 선택되는 알고리즘입니다. Fixed Window의 경계 효과 문제를 완전히 해결하지만, 그 대가로 높은 메모리 비용과 구현 복잡도를 감수해야 합니다.

### 1.2 평가 관점
- **정확성 vs 효율성**: 트레이드오프 이해도
- **데이터 구조 선택**: Sorted Set 사용 이유
- **메모리 최적화**: 높은 메모리 사용량 대응 방안
- **실용성**: 언제 사용해야 하는지 판단력

## 2. 핵심 평가 포인트

### 2.1 Fixed Window 경계 효과 이해 ⭐⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] Fixed Window의 경계 효과 문제를 정확히 이해하는가?
- [ ] Sliding Window가 이를 어떻게 해결하는지 설명할 수 있는가?
- [ ] 시간에 따른 윈도우 슬라이딩 개념을 이해하는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "Fixed Window에서 윈도우 경계에서 어떤 문제가 발생하고, Sliding Window가 이를 어떻게 해결하나요?"

**기대 답변**:
```
Fixed Window 문제:
시간: |--5초--|--5초--|
요청: XXX_____ XXXXX___
4초 59초에 3개 + 5초 01초에 3개 = 2초 간격에 6개!

Sliding Window 해결:
각 시점에서 최근 5초간만 정확히 카운트
4초 59초 요청 후 → 9초 59초까지만 유효
```

#### Trade-offs 이해도 확인
**장점**: 완벽한 정확성, 경계 효과 없음
**단점**: 높은 메모리 사용량, 복잡한 구현

**⭐ 심화 질문**: "정확성을 위해 메모리를 많이 사용하는 게 항상 좋은 선택일까요?"

### 2.2 Redis Sorted Set 활용 ⭐⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] Sorted Set을 선택한 이유를 설명할 수 있는가?
- [ ] ZREMRANGEBYSCORE, ZCARD, ZADD 연산을 적절히 사용하는가?
- [ ] 고유한 요청 ID 생성 방법을 구현했는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "왜 Sorted Set을 선택했나요? Hash나 List는 안 되나요?"

**기대 답변**:
- **Hash**: 시간 범위 쿼리 불가능
- **List**: 중간 요소 삭제 비효율적 (O(N))
- **Set**: 순서 없음, 시간 기반 정렬 불가
- **Sorted Set**: 시간 기반 정렬 + 범위 쿼리 + 효율적 삭제

**⭐ 심화 질문**: "동일한 타임스탬프를 가진 요청들은 어떻게 구분하나요?"

**기대 답변**:
```kotlin
val requestId = "${nowMs}_${(Math.random() * 1000).toInt()}"
// 또는 UUID, AtomicLong 등 활용
```

#### 성능 분석
- **ZREMRANGEBYSCORE**: O(log(N) + M)
- **ZCARD**: O(1)  
- **ZADD**: O(log(N))
- **전체 복잡도**: O(log(N) + M) - 일반적으로 효율적

### 2.3 메모리 사용량 최적화 ⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] 메모리 사용량이 높다는 단점을 인식하는가?
- [ ] TTL 설정으로 메모리 누수를 방지하는가?
- [ ] 메모리 최적화 방안을 제시할 수 있는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "Sliding Window의 메모리 사용량을 줄이려면 어떻게 해야 할까요?"

**기대 답변**:
1. **적절한 TTL**: `windowSize * 2` 설정으로 안전한 정리
2. **압축**: 요청 ID 대신 카운터 사용
3. **하이브리드**: 짧은 윈도우는 Sliding, 긴 윈도우는 Fixed
4. **배치 정리**: 주기적으로 오래된 데이터 일괄 삭제

**⭐ 심화 질문**: "메모리 사용량과 정확성 사이의 균형점은 어디일까요?"

### 2.4 실제 사용 시나리오 판단 ⭐⭐⭐

#### WHAT을 확인하세요
- [ ] 언제 Sliding Window를 사용해야 하는지 아는가?
- [ ] 다른 알고리즘과의 적절한 비교가 가능한가?
- [ ] 실제 비즈니스 요구사항과 연결지을 수 있는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "어떤 상황에서 Sliding Window를 선택하시겠습니까?"

**기대 답변**:
- **금융 API**: 정확한 거래 횟수 제한
- **보안 인증**: 로그인 시도 정밀 제어
- **규제 준수**: 컴플라이언스 요구사항
- **프리미엄 서비스**: 정확한 과금을 위한 사용량 추적

**부적절한 상황**:
- 높은 트래픽 + 메모리 제약
- 버스트 트래픽 허용이 중요한 경우
- 단순한 내부 API 보호

## 3. 심화 평가 질문

### 3.1 확장성 (Scalability) ⭐⭐⭐⭐

**질문**: "하루에 100억 요청을 처리해야 한다면 Sliding Window를 어떻게 최적화하겠습니까?"

**기대 답변**:
- **샤딩**: 사용자 기반 Redis 클러스터 분산
- **메모리 최적화**: 압축, 배치 정리
- **하이브리드 접근**: 중요한 API만 Sliding Window
- **계층적 제한**: 초/분/시간 단위별 다른 알고리즘

### 3.2 정확성 vs 성능 ⭐⭐⭐⭐⭐

**질문**: "정확성이 중요한 금융 API와 성능이 중요한 소셜 미디어 API를 어떻게 다르게 구현하겠습니까?"

**기대 답변**:
- **금융 API**: Sliding Window (정확성 우선)
- **소셜 미디어**: Token Bucket (성능 우선)
- **하이브리드**: 중요도에 따른 알고리즘 선택

### 3.3 데이터 일관성 ⭐⭐⭐⭐

**질문**: "Redis 클러스터 환경에서 Sliding Window의 일관성은 어떻게 보장하나요?"

**기대 답변**:
- **단일 샤드**: 사용자별 데이터를 동일 샤드에 배치
- **Lua Script**: 원자적 연산으로 일관성 보장
- **Read Replica**: 읽기 전용 복제본 활용 고려

## 4. 점수 기준

### 4.1 기본 구현 (60점)
- [ ] Sorted Set 기반 구현
- [ ] 기본적인 슬라이딩 윈도우 로직
- [ ] 오래된 요청 제거 구현

### 4.2 고급 구현 (80점)
- [ ] Lua Script 원자적 연산
- [ ] 고유 요청 ID 생성
- [ ] TTL 기반 메모리 관리
- [ ] 상세한 에러 메시지

### 4.3 우수한 구현 (90점 이상)
- [ ] 경계 효과 문제 정확한 이해
- [ ] 메모리 최적화 방안 제시
- [ ] 적절한 사용 시나리오 판단
- [ ] 성능/정확성 트레이드오프 분석

## 5. 일반적인 실수와 지적 포인트

### 5.1 잘못된 데이터 구조 선택
❌ **잘못된 접근**:
```kotlin
// List 사용 - 중간 삭제 비효율적
redis.lpush(key, timestamp)
redis.lrem(key, count, oldTimestamp) // O(N) 연산!
```

✅ **올바른 접근**: Sorted Set으로 효율적 범위 연산

### 5.2 동일 타임스탬프 처리 누락
❌ **문제**: 동일한 밀리초에 여러 요청시 중복 제거됨
✅ **해결**: 고유한 요청 ID 생성

### 5.3 메모리 누수
❌ **문제**: TTL 설정 없이 무한 증가
✅ **해결**: 적절한 TTL과 정리 로직

### 5.4 성능 고려 부족
❌ **문제**: 매번 전체 Sorted Set 스캔
✅ **해결**: 범위 기반 효율적 연산

## 6. 면접 진행 팁

### 6.1 순서
1. 경계 효과 문제 설명 요청 (5분)
2. Sorted Set 선택 이유 질문 (10분)
3. 메모리 최적화 방안 토론 (10분)
4. 실제 사용 시나리오 논의 (5분)

### 6.2 핵심 체크 포인트
- Fixed Window 문제점을 명확히 이해하는가?
- 데이터 구조 선택에 논리적 근거가 있는가?
- 메모리 사용량 문제를 인식하고 대안을 제시하는가?
- 정확성과 효율성 사이의 트레이드오프를 이해하는가?

## 7. 마무리

Sliding Window는 **완벽한 정확성**이 필요한 상황에서 선택하는 프리미엄 솔루션입니다. 지원자가 이 알고리즘의 가치와 비용을 모두 이해하고, 적절한 상황 판단을 할 수 있는지 평가해주세요.

**좋은 답변의 특징**:
- 정확성의 중요성과 메모리 비용을 모두 언급
- 구체적인 사용 시나리오 제시
- 다른 알고리즘과의 명확한 비교
- 실무적 최적화 방안 제시