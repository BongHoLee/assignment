# Redis 기반 Rate Limiter 면접관 평가 가이드

## 1. 평가 개요

### 1.1 평가 목적
이 가이드는 면접관이 지원자의 Rate Limiter 구현을 체계적으로 평가할 수 있도록 돕는 도구입니다. 
지원자의 **기술적 역량**, **설계 사고력**, **트레이드오프 이해도**를 종합적으로 판단할 수 있는 기준을 제시합니다.

### 1.2 평가 기준
- **WHAT**: 무엇을 구현했는가 (기능적 완성도)
- **HOW**: 어떻게 구현했는가 (기술적 접근법)
- **WHY**: 왜 이렇게 구현했는가 (설계 판단력)
- **Trade-offs**: 선택한 방법의 장단점을 이해하고 있는가

## 2. 핵심 평가 포인트

### 2.1 알고리즘 선택: Fixed Window ⭐⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] Fixed Window 알고리즘을 정확히 구현했는가?
- [ ] 윈도우 시작 시간 계산이 올바른가? (`floor(now/windowSize) * windowSize`)
- [ ] 새 윈도우 시작 시 카운터 초기화가 되는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "다른 Rate Limiting 알고리즘(Sliding Window, Token Bucket)도 있는데 왜 Fixed Window를 선택했나요?"

**기대 답변**:
- **단순함**: 구현이 직관적이고 이해하기 쉬움
- **일관성**: 모든 사용자가 동일한 윈도우 경계 적용
- **성능**: Redis에서 원자적 연산으로 구현하기 용이
- **메모리 효율**: 사용자당 최소한의 상태 정보만 필요

#### Trade-offs 이해도 확인
**장점**:
- 구현의 단순함과 높은 성능
- 메모리 효율적 (사용자당 2개 값만 저장)
- Redis 원자적 연산으로 동시성 보장

**단점**:
- 경계 효과 (Boundary Effect): 윈도우 경계에서 순간적으로 2x 요청 가능
- 트래픽 버스트: 윈도우 시작 직후 모든 요청이 몰릴 수 있음

**⭐ 심화 질문**: "Fixed Window의 경계 효과 문제를 어떻게 완화할 수 있을까요?"

### 2.2 Redis + Lua Script 활용 ⭐⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] Lua Script를 사용하여 원자적 연산을 구현했는가?
- [ ] 모든 Redis 연산이 하나의 스크립트 안에 포함되어 있는가?
- [ ] TTL 설정이 적절하게 되어 있는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "왜 여러 Redis 명령어 대신 Lua Script를 사용했나요?"

**기대 답변**:
- **원자성**: 모든 연산이 원자적으로 실행되어 동시성 문제 해결
- **성능**: 네트워크 라운드트립 최소화
- **일관성**: Race Condition 방지

**⭐ 심화 질문**: "Lua Script 없이 Redis 명령어만으로 구현한다면 어떤 문제가 발생할까요?"

**기대 답변**:
```kotlin
// 문제가 있는 접근법 예시
val current = redisTemplate.opsForHash().get(key, "count") // 1번째 네트워크 호출
if (current < limit) {
    redisTemplate.opsForHash().increment(key, "count", 1) // 2번째 네트워크 호출
    // ⚠️ 이 사이에 다른 요청이 끼어들 수 있음!
}
```

#### Trade-offs 이해도 확인
**장점**:
- 완벽한 원자성과 동시성 보장
- 높은 성능 (단일 네트워크 호출)
- Redis 서버에서 실행되어 지연 시간 최소

**단점**:
- Lua Script 문법 학습 필요
- 디버깅이 상대적으로 어려움
- 스크립트 수정 시 배포 필요

### 2.3 사용자 식별 전략 ⭐⭐⭐

#### WHAT을 확인하세요
- [ ] 여러 소스에서 사용자 ID를 추출하는가? (헤더, 토큰, IP 등)
- [ ] 우선순위가 명확한가?
- [ ] 기본값(fallback) 처리가 있는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "사용자 식별 우선순위를 어떻게 정했나요?"

**기대 답변**:
1. `X-User-Id` 헤더: 명시적 사용자 식별
2. `User-Id` 헤더: 표준 대안
3. `Authorization` 헤더: 토큰 기반 인증
4. IP 주소: 최후 수단

**⭐ 심화 질문**: "IP 기반 식별의 문제점은 무엇인가요?"

**기대 답변**:
- NAT/프록시로 인한 여러 사용자의 동일 IP
- 모바일 환경에서 IP 변경
- CDN/로드밸런서 IP 문제

#### Trade-offs 이해도 확인
**유연성 vs 복잡성**: 다양한 식별 방법을 지원하면 유연하지만 로직이 복잡해짐

### 2.4 AOP 활용 ⭐⭐⭐⭐

#### WHAT을 확인하세요
- [ ] `@Around` 어노테이션을 올바르게 사용했는가?
- [ ] 메서드 실행 전에 Rate Limiting을 체크하는가?
- [ ] 제한 시 적절한 HTTP 상태 코드(429)를 반환하는가?

#### WHY를 물어보세요
**⭐ 중요 질문**: "AOP를 사용한 이유는 무엇인가요?"

**기대 답변**:
- **관심사 분리**: 비즈니스 로직과 Rate Limiting 로직 분리
- **투명성**: 기존 코드 변경 없이 기능 추가
- **재사용성**: 여러 메서드에 동일한 로직 적용 가능

**⭐ 심화 질문**: "Filter나 Interceptor 대신 AOP를 선택한 이유는?"

**기대 답변**:
- Filter: 모든 요청에 적용되어 세밀한 제어 어려움
- Interceptor: Controller 레벨에서만 동작
- AOP: 메서드 레벨에서 세밀한 제어 가능

### 2.5 에러 처리 및 응답 설계 ⭐⭐⭐

#### WHAT을 확인하세요
- [ ] HTTP 429 상태 코드 사용
- [ ] 명확한 에러 메시지 제공
- [ ] Retry-After 정보 포함

#### WHY를 물어보세요
**⭐ 중요 질문**: "에러 응답에 어떤 정보를 포함했고 왜 그렇게 했나요?"

**기대 답변**:
- **Rate Limit 정보**: 현재 제한 규칙 (3 requests per 5 seconds)
- **Retry 시간**: 언제 다시 시도할 수 있는지
- **명확한 메시지**: 클라이언트가 이해하기 쉬운 설명

## 3. 심화 평가 질문

### 3.1 확장성 (Scalability) ⭐⭐⭐⭐⭐

**질문**: "이 시스템을 100배 확장해야 한다면 어떤 문제가 생기고 어떻게 해결하겠습니까?"

**기대 답변**:
- **Redis 병목**: Redis 클러스터링, 샤딩
- **네트워크 비용**: 로컬 캐시 + Redis 조합
- **Hot Key 문제**: 인기 사용자의 키에 요청 집중
- **메모리 사용량**: TTL 최적화, 압축

### 3.2 가용성 (Availability) ⭐⭐⭐⭐

**질문**: "Redis가 다운되면 어떻게 될까요? 어떻게 대응하겠습니까?"

**기대 답변**:
- **현재 상태**: Redis 다운 시 모든 요청 실패
- **개선 방안**: 
  - Redis Sentinel로 자동 페일오버
  - Fallback 메커니즘 (모든 요청 허용 또는 로컬 메모리 사용)
  - Circuit Breaker 패턴 적용

### 3.3 성능 최적화 ⭐⭐⭐⭐

**질문**: "지연 시간을 더 줄이려면 어떻게 하겠습니까?"

**기대 답변**:
- **로컬 캐시**: 자주 조회하는 데이터 로컬 저장
- **배치 처리**: 여러 요청을 묶어서 처리
- **비동기 처리**: Rate Limit 체크를 비동기로 처리
- **Redis 튜닝**: 커넥션 풀, 파이프라인 최적화

### 3.4 모니터링 ⭐⭐⭐

**질문**: "프로덕션에서 이 시스템을 어떻게 모니터링하겠습니까?"

**기대 답변**:
- **지표**: 요청 수, 제한 횟수, 응답 시간
- **알람**: 높은 제한 비율, Redis 연결 실패
- **로깅**: 제한된 요청에 대한 상세 로그
- **대시보드**: 실시간 Rate Limiting 상태

## 4. 점수 기준

### 4.1 기본 구현 (60점)
- [ ] Fixed Window 알고리즘 구현
- [ ] Redis 연동
- [ ] AOP 적용
- [ ] 기본 에러 처리

### 4.2 고급 구현 (80점)
- [ ] Lua Script 사용
- [ ] 적절한 사용자 식별
- [ ] 상세한 에러 메시지
- [ ] 코드 품질 (주석, 구조화)

### 4.3 우수한 구현 (90점 이상)
- [ ] 트레이드오프 이해
- [ ] 확장성 고려사항
- [ ] 모니터링 계획
- [ ] 대안 알고리즘 지식

## 5. 일반적인 실수와 지적 포인트

### 5.1 동시성 문제 무시
❌ **잘못된 접근**:
```kotlin
val count = redis.get(key)
if (count < limit) {
    redis.incr(key) // Race condition!
}
```

✅ **올바른 접근**: Lua Script로 원자적 연산

### 5.2 메모리 누수
❌ **문제**: TTL 설정 없이 Redis 키 무한 증가
✅ **해결**: 적절한 TTL 설정

### 5.3 사용자 식별 부족
❌ **문제**: 하드코딩된 사용자 ID 또는 식별 불가
✅ **해결**: 다양한 소스에서 유연한 사용자 식별

### 5.4 에러 응답 부실
❌ **문제**: 단순한 "Too Many Requests" 메시지
✅ **해결**: 구체적인 제한 정보와 재시도 시간 포함

## 6. 면접 진행 팁

### 6.1 순서
1. 구현 내용 설명 요청 (5분)
2. 핵심 기술 결정 이유 질문 (10분)
3. 심화 질문 및 확장성 논의 (10분)
4. 트레이드오프 및 대안 논의 (5분)

### 6.2 체크 포인트
- 지원자가 자신의 코드를 명확히 설명할 수 있는가?
- 기술적 선택의 이유를 논리적으로 제시하는가?
- 시스템의 한계를 인식하고 개선 방안을 제시하는가?
- 다른 접근법과의 트레이드오프를 이해하는가?

이 가이드를 통해 지원자의 기술적 역량과 시스템 설계 사고력을 종합적으로 평가할 수 있습니다.