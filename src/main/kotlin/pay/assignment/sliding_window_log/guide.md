# Sliding Window Log 구현 평가 가이드 (v2)

## WHAT - 구현한 내용

### 핵심 알고리즘: Sliding Window Log
- **요청 기록**: 각 요청의 정확한 타임스탬프를 큐에 저장
- **윈도우 이동**: 시간 흐름에 따라 연속적으로 윈도우 이동
- **실시간 정리**: 윈도우 범위를 벗어난 오래된 요청 즉시 제거
- **정밀 계산**: 남은 시간과 재시도 시각을 밀리초 단위로 계산

### 구현 구조
```
SlidingWindowLogState: 사용자별 요청 로그 관리
├── requestLog: ConcurrentLinkedQueue<Long> (요청 시각 저장)
├── lastCleanupMillis: Long (TTL 관리용)
├── decide(): 허용/거부 결정 및 로그 업데이트
├── cleanupExpiredRequests(): 만료된 요청 제거
└── calculateRetryAfter(): 정밀한 재시도 시간 계산

SlidingWindowLogLimiter: 전체 관리자
├── ConcurrentHashMap<StateKey, SlidingWindowLogState>
├── check() / checkAt(): 시각 기준 검사
├── cleanupExpired(): 비활성 사용자 정리
└── 모니터링 메서드들 (getActiveUserCount, getUserRequestCount)
```

### 동작 흐름 예시 (5초 윈도우, 3개 제한)
```
시간: 0s→1s→2s→3s→4s→5s→6s→7s
요청: ✓  ✓  ✓        ✓

7초 시점 검사:
- 로그: [1000ms, 2000ms, 3000ms, 6000ms]
- 윈도우: [2000ms ~ 7000ms]
- 정리 후: [2000ms, 3000ms, 6000ms] → 3개
- 결과: 차단 (limit 도달)

8초 시점 검사:  
- 로그: [2000ms, 3000ms, 6000ms]
- 윈도우: [3000ms ~ 8000ms]
- 정리 후: [3000ms, 6000ms] → 2개
- 결과: 허용
```

## WHY - 설계 결정의 이유

### 1. Sliding Window Log 선택 이유

**Q: 왜 Sliding Window Log를 선택했나요?**
- **완벽한 정확도**: 각 요청의 정확한 시각을 기록하여 오차 없는 제한
- **실시간 반영**: 윈도우가 연속적으로 이동하며 경계 문제 해결
- **공정한 처리**: 모든 요청이 동일한 정밀한 기준으로 평가
- **투명한 계산**: 정확히 언제 다음 요청이 가능한지 계산

**Q: Token Bucket 대비 어떤 장점이 있나요?**
- **정확성**: Token Bucket의 근사치 vs 완벽한 정확도
- **경계 처리**: 윈도우 경계에서의 급증 문제 완전 해결  
- **재시도 계산**: 다음 허용 시각을 밀리초 단위로 정밀 계산
- **감사 가능**: 모든 요청 기록이 투명하게 추적 가능

### 2. ConcurrentLinkedQueue 선택 이유

**Q: 왜 ConcurrentLinkedQueue를 사용했나요?**
- **FIFO 보장**: 요청 시각 순서대로 정확한 처리
- **Thread-Safe**: 기본적인 동시성 지원
- **효율적인 삽입/삭제**: offer()와 poll() 연산이 O(1)
- **메모리 효율**: 동적 크기 조절로 불필요한 메모리 사용 없음

**Q: 다른 자료구조는 고려하지 않았나요?**
- **ArrayList**: 중간 요소 삭제 시 O(n) 비용
- **LinkedList**: Thread-safe하지 않음
- **TreeSet**: 정렬 오버헤드가 불필요 (이미 시간순)
- **ArrayDeque**: Thread-safe하지 않음

### 3. 동기화 전략 선택 이유

**Q: ConcurrentLinkedQueue인데 왜 synchronized가 필요한가요?**
- **복합 연산**: peek() + poll()의 원자성 보장 필요
- **상태 일관성**: 요청 수 계산과 로그 업데이트의 일관성
- **결정의 정확성**: 동시 요청 시 정확한 허용/거부 판단

**Q: 더 세밀한 락 전략은 고려하지 않았나요?**
- **ReadWriteLock**: 읽기가 적고 쓰기가 많은 워크로드에 부적합
- **StampedLock**: 복잡성 대비 성능 이득 미미
- **Lock-free**: 복합 연산의 원자성 보장 어려움

## Trade-offs 분석

### 장점 vs 단점

| 장점 | 단점 |
|------|------|
| **완벽한 정확도**: 100% 정밀한 제한 | **메모리 사용**: 요청 수에 비례 증가 |
| **실시간 처리**: 경계 문제 없음 | **처리 복잡도**: O(k) 정리 작업 필요 |
| **정밀 계산**: 밀리초 단위 재시도 | **구현 복잡도**: 상대적으로 복잡한 로직 |
| **투명성**: 모든 요청 기록 추적 | **메모리 정리**: 주기적 정리 로직 필요 |

### 다른 알고리즘과의 성능 비교

#### vs Token Bucket
- **정확성**: Sliding Log >> Token Bucket
- **메모리**: Sliding Log > Token Bucket (~44% 증가)
- **처리속도**: Sliding Log < Token Bucket (O(k) vs O(1))
- **복잡성**: Sliding Log > Token Bucket

#### vs Fixed Window
- **정확성**: Sliding Log >> Fixed Window  
- **메모리**: Sliding Log >> Fixed Window (요청 수 vs 카운터)
- **처리속도**: Sliding Log < Fixed Window
- **경계 문제**: Sliding Log가 완전 해결

#### vs Sliding Window Counter (예상)
- **정확성**: Sliding Log > Sliding Counter
- **메모리**: Sliding Log > Sliding Counter
- **처리속도**: Sliding Log < Sliding Counter
- **구현**: 비슷한 복잡도

## 면접 질문 및 답변 가이드

### 기술적 질문

**Q: 메모리 사용량이 계속 증가하지 않나요?**
A: 두 가지 정리 메커니즘이 있습니다:
1. **자동 정리**: 각 요청 시 윈도우 범위 밖 요청 즉시 제거
2. **주기적 정리**: `cleanupExpired()`로 비활성 사용자 상태 제거
최대 메모리는 `활성_사용자_수 × 제한값 × 24bytes`로 제한됩니다.

**Q: ConcurrentLinkedQueue의 poll() 연산이 안전한가요?**
A: 기본적으로 thread-safe하지만, peek() + poll() 복합 연산을 synchronized로 보호합니다. 이는 "확인 후 제거"의 원자성을 보장하기 위함입니다.

**Q: 큐의 정리 작업이 성능에 미치는 영향은?**
A: 평균적으로 O(1)~O(3) 수준입니다. 제한값이 3이므로 최대 3개의 만료된 요청만 제거하면 됩니다. 최악의 경우에도 제한값에 비례하므로 상수 시간에 가깝습니다.

### 설계 질문

**Q: 왜 나노초가 아닌 밀리초를 사용했나요?**
A: Rate Limiting의 정확도 요구사항과 메모리 효율성의 균형점입니다. 밀리초 정밀도로도 충분히 정확하며, 나노초는 오버엔지니어링이 될 수 있습니다.

**Q: 대용량 트래픽에서는 어떻게 동작하나요?**
A: 사용자별 독립적 처리로 확장성을 보장합니다. 다만 메모리 사용량이 선형 증가하므로, 매우 높은 트래픽에서는 하이브리드 접근(v5)이나 Redis 기반(v4)을 고려해야 합니다.

**Q: 시스템 클럭 변경에 어떻게 대응하나요?**
A: 상대적 시간 차이를 사용하므로 작은 클럭 변경에는 영향받지 않습니다. 다만 큰 변경 시에는 전체 상태 재설정이 필요할 수 있습니다.

### 최적화 질문

**Q: 성능을 더 개선할 방법이 있나요?**
A: 
1. **배치 정리**: 여러 요청을 모아서 한 번에 정리
2. **LRU 캐시**: 가장 활성화된 사용자만 메모리에 보관
3. **파티셔닝**: 사용자별 상태를 여러 맵으로 분산

**Q: 메모리를 더 절약할 방법이 있나요?**
A:
1. **압축된 타임스탬프**: 상대적 시간으로 int 사용
2. **원형 버퍼**: 고정 크기 배열 사용 (정확도 trade-off)
3. **하이브리드**: 최근 요청만 정확히, 오래된 것은 근사치

### 비교 분석 질문

**Q: 언제 Token Bucket 대신 이 방식을 선택해야 하나요?**
A:
- **정확성이 중요**: 결제, 보안, 컴플라이언스
- **공정성이 필요**: 모든 사용자 동일 대우
- **감사가 필요**: 요청 기록 추적 필요
- **낮은 제한값**: 메모리 오버헤드가 허용 가능

**Q: Fixed Window와 비교했을 때의 핵심 차이는?**
A: "경계 문제"의 완전한 해결입니다. Fixed Window는 윈도우 경계에서 2배 트래픽이 가능하지만, Sliding Window Log는 어떤 시점에서도 정확한 제한을 보장합니다.

## 평가 기준별 체크포인트

### 정확성 (30점) - 가장 높은 비중
- [ ] 5초/3회 제한의 완벽한 구현 (오차 없음)
- [ ] 윈도우 경계 문제 완전 해결
- [ ] 재시도 시간의 밀리초 단위 정확성
- [ ] 동시 요청에서의 정확한 제한

### 성능 (20점)
- [ ] 적절한 시간 복잡도 (평균 O(1)~O(3))  
- [ ] 메모리 사용량의 예측 가능성
- [ ] 대량 사용자에서의 확장성
- [ ] 정리 작업의 효율성

### 동시성 (25점)
- [ ] Thread-safe한 큐 사용
- [ ] 복합 연산의 원자성 보장
- [ ] 사용자별 독립적 처리
- [ ] 데드락 없는 구현

### 코드 품질 (25점)
- [ ] 명확한 책임 분리 (State vs Limiter)
- [ ] 상세한 주석과 문서화
- [ ] 모니터링 기능 제공
- [ ] 확장 가능한 인터페이스 설계

## 심화 질문

**Q: 분산 환경에서 이 알고리즘을 어떻게 적용할 수 있나요?**
A: Redis의 Sorted Set을 사용하여 타임스탬프를 score로 저장하고, ZREMRANGEBYSCORE로 만료된 요청을 제거할 수 있습니다. 다만 네트워크 라운드트립으로 인한 성능 trade-off가 있습니다.

**Q: 이 구현의 최대 처리량은 얼마나 될까요?**
A: 단일 사용자당 초당 수천 건의 요청을 처리할 수 있지만, 전체 처리량은 `사용자_수 × 평균_요청_빈도`에 의해 결정됩니다. 메모리가 병목이 될 가능성이 높습니다.

**Q: 실제 프로덕션에서 이 방식을 사용한 사례가 있나요?**
A: Cloudflare, Stripe 등에서 정확한 Rate Limiting이 필요한 API에 사용합니다. 다만 보통 Redis나 분산 시스템과 결합하여 사용합니다.