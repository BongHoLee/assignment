# Token Bucket 구현 평가 가이드 (v1)

## WHAT - 구현한 내용

### 핵심 알고리즘: Token Bucket
- **토큰 충전**: 0.6개/초 속도로 토큰 생성 (3개/5초)
- **토큰 소비**: 요청당 1개 토큰 차감
- **버킷 용량**: 최대 3개 토큰 저장
- **시간 기반**: 밀리초 단위 정밀 계산

### 구현 구조
```
TokenBucketState: 사용자별 상태 관리
├── tokens: 현재 토큰 수 (Double)
├── lastRefillMillis: 마지막 충전 시간
└── decide(): 요청 허용/거부 결정

TokenBucketLimiter: 전체 관리자
├── ConcurrentHashMap<StateKey, TokenBucketState>
├── check(): 현재 시각 기준 검사
└── checkAt(): 지정 시각 기준 검사
```

### AOP 통합
- **@RateLimited** 어노테이션 기반 적용
- **User ID 추출**: Header → Session → IP → Anonymous 순서
- **HTTP 응답**: 429 상태코드 + Retry-After 헤더

## WHY - 설계 결정의 이유

### 1. Token Bucket 선택 이유

**Q: 왜 Token Bucket을 선택했나요?**
- **버스트 허용**: 초기에 3개 요청을 연속으로 처리 가능
- **자연스러운 제한**: 급격한 차단보다는 점진적 제어
- **직관적 이해**: 토큰이라는 개념으로 쉽게 설명 가능
- **실용성**: Netflix, AWS 등에서 검증된 알고리즘

**Q: Fixed Window와 비교했을 때 장점은?**
- **경계 문제 해결**: 윈도우 경계에서의 급증 문제 없음
- **연속성**: 시간에 따른 자연스러운 토큰 충전
- **유연성**: 버스트와 평균 처리율을 독립적으로 제어

### 2. 동시성 전략 선택 이유

**Q: ConcurrentHashMap + synchronized를 선택한 이유는?**
- **사용자별 격리**: 다른 사용자 요청에 영향 없음
- **최소 락 범위**: 전체가 아닌 개별 상태에만 동기화
- **성능**: 읽기 작업이 많은 ConcurrentHashMap 최적화
- **간단함**: ReentrantLock보다 구현과 이해가 쉬움

**Q: 다른 동시성 전략은 고려하지 않았나요?**
- **Atomic 클래스**: Double 타입에 대한 atomic 연산 복잡성
- **Lock-free**: 토큰 충전 로직의 복잡성으로 구현 어려움
- **Actor 모델**: 오버헤드 대비 이점 부족

### 3. 메모리 설계 결정

**Q: 사용자별 상태를 메모리에 저장하는 이유는?**
- **성능**: O(1) 접근 시간
- **요구사항**: 인메모리 기반 명시
- **단순성**: 외부 의존성 없음

**Q: TTL 정리가 필요한 이유는?**
- **메모리 누수 방지**: 비활성 사용자 상태 정리
- **확장성**: 장기간 운영시 메모리 사용량 제어

## Trade-offs 분석

### 장점 vs 단점

| 장점 | 단점 |
|------|------|
| **버스트 허용**: 초기 연속 요청 처리 | **메모리 사용**: 사용자당 ~72 bytes |
| **부드러운 제한**: 점진적 차단 | **부동소수점 오차**: 미세한 정확성 이슈 |
| **높은 성능**: O(1) 시간 복잡도 | **복잡성**: Fixed Window보다 복잡한 로직 |
| **확장성**: 사용자별 독립 처리 | **TTL 관리**: 정리 로직 필요 |

### 다른 알고리즘과의 비교

#### vs Fixed Window
- **정확성**: Fixed < Token Bucket (경계 문제 해결)
- **메모리**: Fixed < Token Bucket (카운터 vs 상태)
- **복잡성**: Fixed < Token Bucket
- **버스트**: Fixed < Token Bucket

#### vs Sliding Window Log  
- **정확성**: Token Bucket < Sliding Window Log
- **메모리**: Token Bucket << Sliding Window Log
- **성능**: Token Bucket > Sliding Window Log
- **복잡성**: Token Bucket < Sliding Window Log

## 면접 질문 및 답변 가이드

### 기술적 질문

**Q: 토큰 충전 계산에서 부동소수점을 사용하는 이유는?**
A: 정밀한 시간 계산을 위해서입니다. 0.6개/초 충전율을 정확히 표현하려면 부동소수점이 필요합니다. 정수만 사용하면 충전 타이밍이 부정확해집니다.

**Q: synchronized 블록 대신 ReentrantLock을 사용할 수 있나요?**
A: 가능합니다. ReentrantLock은 더 세밀한 제어(timeout, fair/unfair)가 가능하지만, 현재 요구사항에서는 synchronized가 더 간단하고 충분합니다.

**Q: 토큰이 음수가 될 수 있나요?**
A: 현재 구현에서는 불가능합니다. `tokens >= 1.0` 검사 후에만 차감하므로 음수가 될 수 없습니다.

### 설계 질문

**Q: 분산 환경에서는 어떻게 동작하나요?**
A: 현재 구현은 단일 인스턴스용입니다. 분산 환경에서는 Redis나 데이터베이스 기반 구현이 필요합니다. 이는 v4에서 다룰 예정입니다.

**Q: 사용자 식별 방법이 보안상 문제없나요?**
A: Header는 조작 가능하므로 보안이 중요한 환경에서는 JWT 토큰이나 인증된 사용자 ID를 사용해야 합니다. 현재는 데모용 구현입니다.

**Q: 메모리 사용량이 계속 증가하지 않나요?**
A: `cleanupExpired()` 메서드로 비활성 사용자를 정리합니다. 실제 운영에서는 @Scheduled로 주기적 실행이 필요합니다.

### 최적화 질문

**Q: 성능을 더 개선할 방법이 있나요?**
A: 
1. **배치 처리**: 여러 요청을 한 번에 처리
2. **캐시 최적화**: 자주 접근하는 사용자 상태 캐싱  
3. **Lock-free**: 복잡하지만 더 높은 동시성 가능

**Q: 메모리를 더 절약할 방법이 있나요?**
A:
1. **Primitive 사용**: Double → long (나노초 단위)
2. **압축**: 사용자 ID 해싱
3. **LRU 캐시**: 활성 사용자만 메모리 보관

## 평가 기준별 체크포인트

### 정확성 (25점)
- [ ] 5초/3회 제한 정확히 구현
- [ ] 버스트 트래픽 적절히 처리
- [ ] 시간 경과에 따른 토큰 충전 정확성

### 동시성 (25점)
- [ ] 동시 요청에 대한 안전한 처리
- [ ] 사용자별 독립성 보장
- [ ] 데드락 없는 구현

### 성능 (25점)  
- [ ] O(1) 시간 복잡도
- [ ] 적절한 메모리 사용량
- [ ] 높은 처리량 달성

### 코드 품질 (25점)
- [ ] 명확한 구조와 네이밍
- [ ] 적절한 추상화 레벨
- [ ] 확장 가능한 설계