# Redis 기반 분산 Rate Limiter 구현 평가 가이드 (v4)

## WHAT - 구현한 내용

### 핵심 알고리즘: Redis 기반 Fixed Window
- **분산 상태 관리**: Redis를 중앙 저장소로 사용하여 모든 서버 인스턴스가 공유
- **원자적 연산**: Redis INCR로 경합 조건 없는 정확한 카운팅
- **자동 정리**: EXPIRE 명령으로 윈도우 만료 시 자동 키 삭제
- **Fail-Open**: Redis 장애 시 가용성을 위해 요청 허용

### 구현 구조
```
RedisRateLimiter: 분산 Rate Limiter 메인 클래스
├── RedisClient 인터페이스: Redis 연산 추상화
├── InMemoryRedisClient: 데모용 Redis 시뮬레이션
├── 키 전략: "ratelimit:{userId}:{windowStart}" 
├── checkAt(): Redis 기반 제한 검사
├── 원자적 연산: INCR + EXPIRE 조합
└── 에러 처리: Fail-Open 정책

RedisClient 연산:
├── incr(): 원자적 카운터 증가
├── expire(): TTL 설정으로 자동 정리  
├── ttl(): 남은 수명 확인
├── get(): 현재 값 조회
└── del(): 키 삭제 (관리용)
```

### 분산 아키텍처 흐름
```
[App Server 1] ─┐                   ┌─ INCR ratelimit:user123:1701234000 → 1
[App Server 2] ─┼─→ [Redis Master] ─┼─ EXPIRE ratelimit:user123:1701234000 6
[App Server 3] ─┘        │          └─ Response: allowed=true, remaining=2
                          │
                 [Redis Replica]
```

### Redis 키 전략 예시
```
사용자: user123, 윈도우: 5초, 시각: 2023-11-29 00:02:07

윈도우 계산:
- nowMs = 1701234127000 (07초)
- windowMs = 5000
- windowStartMs = (1701234127000 / 5000) * 5000 = 1701234125000 (05초)
- windowStartSeconds = 1701234125

Redis 키: "ratelimit:user123:1701234125"
TTL: 6초 (윈도우 5초 + 여유 1초)
```

## WHY - 설계 결정의 이유

### 1. Redis 선택 이유

**Q: 왜 Redis를 분산 Rate Limiting의 기반으로 선택했나요?**
- **원자성**: INCR 연산이 thread-safe하고 원자적으로 수행됨
- **성능**: 메모리 기반으로 매우 빠른 응답 속도 (서브밀리초)
- **영속성**: 옵션에 따라 데이터 지속성 보장 가능
- **확장성**: 클러스터 모드로 수평 확장 지원
- **검증됨**: 수많은 프로덕션 환경에서 검증된 안정성

**Q: 다른 분산 저장소 대신 Redis를 선택한 이유는?**

| 저장소 | 장점 | 단점 |
|--------|------|------|
| **Redis** | 원자적 연산, 높은 성능, TTL 지원 | 메모리 기반 비용 |
| **MongoDB** | 복잡한 쿼리, 영속성 | 원자적 연산 복잡, 느림 |
| **DynamoDB** | 완전 관리형, 확장성 | 비용, 복잡한 조건부 업데이트 |
| **Cassandra** | 높은 확장성 | 원자성 보장 어려움 |

### 2. Fixed Window + Redis 선택 이유

**Q: Redis에서 왜 Fixed Window를 사용했나요?**
- **단순성**: INCR + EXPIRE 만으로 구현 가능
- **원자성**: 단일 Redis 명령으로 카운터 증가
- **효율성**: 사용자당 단일 키로 메모리 효율적
- **자동 정리**: TTL로 만료된 윈도우 자동 삭제

**Q: Sliding Window를 Redis로 구현하지 않은 이유는?**
- **복잡성**: Lua 스크립트나 여러 명령 필요
- **성능**: 단일 명령 대비 더 복잡한 연산
- **메모리**: 요청별 타임스탬프 저장 필요
- **우선순위**: v4는 분산 기능에 집중, 정확도는 v5에서 개선

### 3. Fail-Open 정책 선택 이유

**Q: Redis 장애 시 왜 Fail-Open(허용) 정책을 선택했나요?**
- **가용성 우선**: 서비스 중단보다는 일시적 Rate Limit 해제가 나음
- **사용자 경험**: 사용자가 "서비스 불가" 보다는 "잠시 느림"을 선호
- **복구 시간**: Redis 복구 시 자동으로 Rate Limiting 재개
- **선택적 적용**: 중요도에 따라 Fail-Close로 변경 가능

**Q: Fail-Close는 언제 고려해야 하나요?**
- **보안 중요**: DDoS 방어, 인증 시스템
- **비용 절약**: API 호출 비용이 높은 외부 서비스
- **백업 메커니즘**: 로컬 캐시 등 대체 수단이 있는 경우

### 4. TTL 전략

**Q: TTL을 윈도우 크기 + 1초로 설정한 이유는?**
- **안전 여유**: 클럭 스큐, 네트워크 지연 고려
- **메모리 효율**: 불필요한 키 자동 정리
- **일관성**: 윈도우 경계에서의 경합 조건 방지
- **단순성**: 복잡한 정리 로직 불필요

## Trade-offs 분석

### 장점 vs 단점

| 장점 | 단점 |
|------|------|
| **완벽한 분산 지원**: 여러 서버 완전 동기화 | **외부 의존성**: Redis 장애 시 영향 |
| **영속성**: 서버 재시작 후 상태 유지 | **네트워크 지연**: 로컬 처리 대비 느림 |
| **수평 확장**: Redis 클러스터로 무한 확장 | **경계 문제**: Fixed Window 고유 문제 |
| **운영성**: Redis 모니터링 도구 활용 | **인프라 복잡성**: Redis 관리 필요 |
| **검증된 안정성**: 프로덕션 검증 완료 | **비용**: Redis 인프라 비용 |

### 성능 비교 분석

#### 응답 시간 (마이크로초 단위)
```
로컬 Token Bucket: ~1-3μs
로컬 Sliding Counter: ~2-5μs  
Redis Rate Limiter: ~100-1000μs (네트워크 환경에 따라)
```

#### 처리량 (초당 요청)
```
단일 Redis 인스턴스: ~100K req/sec
Redis 클러스터 (3노드): ~300K req/sec
실제 환경 (네트워크 고려): ~10-50K req/sec
```

#### 메모리 효율성
```
로컬 방식: 서버별 독립 저장 (N×메모리)
Redis 방식: 중앙 집중 저장 (1×메모리)
총 메모리: Redis 방식이 더 효율적 (분산 환경에서)
```

## 면접 질문 및 답변 가이드

### 기술적 질문

**Q: Redis INCR 연산의 원자성은 어떻게 보장되나요?**
A: Redis는 단일 스레드 이벤트 루프 모델을 사용합니다. 모든 명령은 순차적으로 실행되므로 INCR 연산이 중간에 끊어질 수 없습니다. 또한 INCR는 키가 없으면 0에서 시작하여 1로 설정하는 것이 하나의 원자적 연산입니다.

**Q: Redis 메모리가 부족하면 어떻게 되나요?**
A: `maxmemory-policy` 설정에 따라 다릅니다:
- `allkeys-lru`: 가장 최근에 사용되지 않은 키 삭제
- `volatile-ttl`: TTL이 있는 키 중 가장 짧은 것 삭제
- `noeviction`: 메모리 부족 시 쓰기 연산 거부
Rate Limiting에서는 `volatile-ttl`이 적합합니다.

**Q: Redis 마스터가 장애나면 어떻게 처리하나요?**
A: Redis Sentinel이나 클러스터 모드를 사용합니다:
1. **Sentinel**: 자동 페일오버로 replica를 master로 승격
2. **Cluster**: 샤드별 master-replica 구조로 부분 장애 대응
3. **Application**: 연결 실패 시 Fail-Open으로 처리

**Q: 클럭 스큐 문제는 어떻게 해결하나요?**
A: 여러 서버의 시계가 다를 때 발생하는 문제입니다:
- **NTP 동기화**: 모든 서버의 시계를 NTP로 동기화
- **여유 시간**: TTL에 여유를 두어 작은 스큐 허용
- **중앙 시간**: Redis에서 TIME 명령으로 기준 시간 사용 가능

### 설계 질문

**Q: Redis 연결 풀 크기는 어떻게 설정해야 하나요?**
A: 
- **기본 공식**: `연결 수 = 동시 요청 수 / 평균 응답 시간`
- **일반적 설정**: CPU 코어 수 × 2-4개
- **모니터링**: 연결 대기 시간, 활성 연결 수 추적
- **부하 테스트**: 실제 부하에서 최적값 측정

**Q: Redis 키 만료 시점이 정확하지 않을 수 있다는데 문제없나요?**
A: Redis는 lazy expiration + active expiration을 사용합니다:
- **Lazy**: 키 접근 시 만료 확인 후 삭제
- **Active**: 백그라운드에서 주기적으로 만료 키 삭제
Rate Limiting에서는 키가 존재하지 않으면 새 윈도우로 처리하므로 문제없습니다.

**Q: 글로벌 서비스에서 지역별 Redis를 어떻게 구성하나요?**
A:
1. **지역별 독립**: 각 지역마다 별도 Redis (지연 시간 최소화)
2. **글로벌 통합**: 단일 Redis 클러스터 (일관성 보장)
3. **하이브리드**: 지역별 + 글로벌 동기화 (복잡하지만 최적)

### 최적화 질문

**Q: 더 빠른 성능을 위해 개선할 수 있는 방법은?**
A:
1. **Pipeline**: 여러 명령을 배치로 처리
2. **Connection Pooling**: 연결 재사용으로 오버헤드 감소
3. **로컬 캐시**: 최근 결과를 로컬에 캐싱 (v5에서 구현)
4. **Lua 스크립트**: 복합 연산을 서버 사이드에서 처리

**Q: Redis 메모리 사용량을 줄이는 방법은?**
A:
1. **키 압축**: 해시 함수로 긴 사용자 ID 단축
2. **TTL 최적화**: 불필요하게 긴 TTL 방지
3. **데이터 압축**: Redis compression 활용
4. **샤딩**: 사용자별로 다른 Redis 인스턴스 사용

### 운영 질문

**Q: Redis Rate Limiter를 모니터링하려면 어떤 지표를 봐야 하나요?**
A:
- **Redis 지표**: 응답 시간, 메모리 사용량, 키 개수, 만료율
- **애플리케이션 지표**: Rate Limit 적중률, Fail-Open 발생 빈도
- **비즈니스 지표**: 사용자별 요청 패턴, 차단된 요청 수

**Q: Redis 백업과 복구 전략은?**
A:
- **RDB 스냅샷**: 주기적 전체 백업 (하루 1회)
- **AOF 로그**: 모든 쓰기 연산 기록 (실시간)
- **복제**: Master-Replica로 실시간 복사
- **Cross-region**: 재해 복구를 위한 지역 간 복제

## 평가 기준별 체크포인트

### 분산 지원 (30점) - 최고 배점
- [ ] 여러 서버에서 동일한 Rate Limit 상태 공유
- [ ] Redis 장애 시 Fail-Open 동작 확인
- [ ] 서버 재시작 후 제한 상태 복구 확인
- [ ] 원자적 연산을 통한 경합 조건 방지

### 성능 (25점)
- [ ] Redis 연산의 효율적 활용 (INCR + EXPIRE)
- [ ] 적절한 네트워크 응답 시간 (1ms 이내)
- [ ] TTL을 통한 자동 메모리 관리
- [ ] 확장 가능한 아키텍처 설계

### 안정성 (25점)
- [ ] Redis 연결 실패 시 에러 처리
- [ ] 적절한 TTL 설정으로 메모리 누수 방지
- [ ] 클럭 스큐 등 분산 환경 이슈 고려
- [ ] 모니터링 가능한 설계

### 코드 품질 (20점)
- [ ] Redis 인터페이스의 깔끔한 추상화
- [ ] 상세한 분산 환경 주석
- [ ] 관리용 메서드 제공 (모니터링, 리셋)
- [ ] 확장 가능한 설계 (다른 Redis 클라이언트 교체 가능)

## 심화 질문

**Q: CAP 이론의 관점에서 이 구현을 어떻게 분석하나요?**
A: 
- **C (Consistency)**: Redis 단일 마스터로 강한 일관성 보장
- **A (Availability)**: Fail-Open으로 가용성 우선 선택
- **P (Partition Tolerance)**: 네트워크 분할 시 가용성 선택
결론: AP 시스템이지만 Redis 클러스터로 CA 특성도 부분적 확보

**Q: 이벤트 소싱 패턴과 결합하면 어떤 장점이 있나요?**
A: 모든 Rate Limit 결정을 이벤트로 저장하면:
- **감사 추적**: 모든 제한 결정 기록 보관
- **패턴 분석**: 사용자별 요청 패턴 분석 가능
- **복구 가능**: 과거 시점으로 상태 복원
- **규정 준수**: 컴플라이언스 요구사항 충족

**Q: 마이크로서비스 환경에서의 Rate Limiting 전략은?**
A:
1. **중앙집중식**: 모든 서비스가 동일 Redis 사용
2. **서비스별**: 각 서비스마다 독립적 Rate Limit
3. **계층적**: API Gateway + 개별 서비스 조합
4. **사용자별**: 사용자 티어에 따른 차등 제한

**Q: 실제 프로덕션에서 이런 구현을 본 적이 있나요?**
A: 
- **Stripe**: 결제 API Rate Limiting에 Redis 사용
- **GitHub**: API Rate Limit을 Redis로 관리
- **Shopify**: Redis + Lua 스크립트로 복잡한 제한 로직
- **Cloudflare**: 엣지에서 Redis 클러스터로 글로벌 제한

이들 모두 이 v4 구현과 유사한 패턴을 사용하며, 실제로 검증된 접근 방식입니다.